use bytes::BufMut;
use std::borrow::Cow;

use nom::{IResult, be_i16, be_i32};

use errors::Result;
use protocol::{parse_response_header, parse_string, ApiVersion, Encodable, ErrorCode, Offset, ParseTag, PartitionId,
               Request, RequestHeader, ResponseHeader, Timestamp, WriteExt, ARRAY_LEN_SIZE, OFFSET_SIZE,
               PARTITION_ID_SIZE, STR_LEN_SIZE, TIMESTAMP_SIZE};

pub const DEFAULT_RETENTION_TIME: i64 = -1;

const GROUP_GENERATION_ID_SIZE: usize = 4;
const RETENTION_TIME: usize = 8;

#[derive(Clone, Debug, PartialEq)]
pub struct OffsetCommitRequest<'a> {
    pub header: RequestHeader<'a>,
    /// The group id.
    pub group_id: Option<Cow<'a, str>>,
    /// The generation of the group.
    pub group_generation_id: Option<i32>,
    /// The member id assigned by the group coordinator.
    pub member_id: Option<Cow<'a, str>>,
    /// Time period in ms to retain the offset.
    pub retention_time: Option<i64>,
    /// Topic to commit.
    pub topics: Vec<OffsetCommitTopic<'a>>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct OffsetCommitTopic<'a> {
    /// The name of the topic.
    pub topic_name: Cow<'a, str>,
    /// Partitions to commit offset.
    pub partitions: Vec<OffsetCommitPartition<'a>>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct OffsetCommitPartition<'a> {
    /// The id of the partition the commit is for.
    pub partition_id: PartitionId,
    /// Message offset to be committed.
    pub offset: Offset,
    /// Timestamp of the commit
    pub timestamp: Timestamp,
    /// Any associated metadata the client wants to keep.
    pub metadata: Option<Cow<'a, str>>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct OffsetCommitResponse {
    pub header: ResponseHeader,
    /// Topics to commit offsets.
    pub topics: Vec<OffsetCommitTopicStatus>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct OffsetCommitTopicStatus {
    /// The name of the topic.
    pub topic_name: String,
    /// Partitions to commit offset.
    pub partitions: Vec<OffsetCommitPartitionStatus>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct OffsetCommitPartitionStatus {
    /// The id of the partition the commit is for.
    pub partition_id: PartitionId,
    /// Error code.
    pub error_code: ErrorCode,
}

impl<'a> Request for OffsetCommitRequest<'a> {
    fn size(&self, api_version: ApiVersion) -> usize {
        self.header.size(api_version) + STR_LEN_SIZE + self.group_id.as_ref().map_or(0, |s| s.len())
            + if api_version > 0 {
                GROUP_GENERATION_ID_SIZE + STR_LEN_SIZE + self.member_id.as_ref().map_or(0, |s| s.len())
            } else {
                0
            } + if api_version > 1 { RETENTION_TIME } else { 0 }
            + self.topics.iter().fold(ARRAY_LEN_SIZE, |size, topic| {
                size + STR_LEN_SIZE + topic.topic_name.len()
                    + topic.partitions.iter().fold(ARRAY_LEN_SIZE, |size, partition| {
                        size + PARTITION_ID_SIZE + OFFSET_SIZE + if api_version == 1 { TIMESTAMP_SIZE } else { 0 }
                            + STR_LEN_SIZE + partition.metadata.as_ref().map_or(0, |s| s.len())
                    })
            })
    }
}

impl<'a> Encodable for OffsetCommitRequest<'a> {
    fn encode<T: BufMut>(&self, dst: &mut T) -> Result<()> {
        let api_version = self.header.api_version;

        self.header.encode(dst)?;

        dst.put_str(self.group_id.as_ref())?;
        if api_version > 0 {
            dst.put_i32_be(self.group_generation_id.unwrap_or_default());
            dst.put_str(self.member_id.as_ref())?;
        }
        if api_version > 1 {
            dst.put_i64_be(self.retention_time.unwrap_or(DEFAULT_RETENTION_TIME));
        }
        dst.put_array(&self.topics, |buf, topic| {
            buf.put_str(Some(topic.topic_name.as_ref()))?;
            buf.put_array(&topic.partitions, |buf, partition| {
                buf.put_i32_be(partition.partition_id);
                buf.put_i64_be(partition.offset);
                if api_version == 1 {
                    buf.put_i64_be(partition.timestamp);
                }
                buf.put_str(partition.metadata.as_ref())
            })
        })
    }
}

impl OffsetCommitResponse {
    pub fn parse(buf: &[u8]) -> IResult<&[u8], Self> {
        parse_offset_commit_response(buf)
    }
}

named!(
    parse_offset_commit_response<OffsetCommitResponse>,
    parse_tag!(
        ParseTag::OffsetCommitResponse,
        do_parse!(
            header: parse_response_header >> topics: length_count!(be_i32, parse_offset_commit_topic_status)
                >> (OffsetCommitResponse { header, topics })
        )
    )
);

named!(
    parse_offset_commit_topic_status<OffsetCommitTopicStatus>,
    parse_tag!(
        ParseTag::OffsetCommitTopicStatus,
        do_parse!(
            topic_name: parse_string >> partitions: length_count!(be_i32, parse_offset_commit_partition_status)
                >> (OffsetCommitTopicStatus { topic_name, partitions })
        )
    )
);

named!(
    parse_offset_commit_partition_status<OffsetCommitPartitionStatus>,
    parse_tag!(
        ParseTag::OffsetCommitPartitionStatus,
        do_parse!(
            partition_id: be_i32 >> error_code: be_i16 >> (OffsetCommitPartitionStatus {
                partition_id,
                error_code,
            })
        )
    )
);

#[cfg(test)]
mod tests {
    use super::*;
    use bytes::BytesMut;

    use nom::IResult;
    use protocol::*;

    #[test]
    fn test_encode_offset_commit_request_v0() {
        let req = OffsetCommitRequest {
            header: RequestHeader {
                api_key: ApiKeys::OffsetCommit as ApiKey,
                api_version: 0,
                correlation_id: 123,
                client_id: Some("client".into()),
            },
            group_id: Some("consumer".into()),
            group_generation_id: Default::default(),
            member_id: Some("member".into()),
            retention_time: None,
            topics: vec![
                OffsetCommitTopic {
                    topic_name: "topic".into(),
                    partitions: vec![
                        OffsetCommitPartition {
                            partition_id: 5,
                            offset: 6,
                            timestamp: Default::default(),
                            metadata: Some("metadata".into()),
                        },
                    ],
                },
            ],
        };

        let data = vec![
            /* OffsetCommitRequest
             * RequestHeader */ 0, 8 /* api_key */, 0,
            0 /* api_version */, 0, 0, 0, 123 /* correlation_id */, 0, 6, b'c', b'l', b'i', b'e', b'n',
            b't' /* client_id */, 0, 8, b'c', b'o', b'n', b's', b'u', b'm', b'e', b'r' /* group_id */,
            /* topics: [OffsetCommitTopic] */ 0, 0, 0, 1, /* OffsetCommitTopic */ 0, 5, b't', b'o', b'p',
            b'i', b'c' /* topic_name */, /* partitions: [OffsetCommitPartition] */ 0, 0, 0, 1,
            /* OffsetCommitPartition */ 0, 0, 0, 5 /* partition */, 0, 0, 0, 0, 0, 0, 0, 6 /* offset */,
            0, 8, b'm', b'e', b't', b'a', b'd', b'a', b't', b'a' /* metadata */,
        ];

        let mut buf = BytesMut::with_capacity(128);

        req.encode(&mut buf).unwrap();

        assert_eq!(req.size(req.header.api_version), buf.len());

        assert_eq!(&buf[..], &data[..]);
    }

    #[test]
    fn test_encode_offset_commit_request_v1() {
        let req = OffsetCommitRequest {
            header: RequestHeader {
                api_key: ApiKeys::OffsetCommit as ApiKey,
                api_version: 1,
                correlation_id: 123,
                client_id: Some("client".into()),
            },
            group_id: Some("consumer".into()),
            group_generation_id: Some(456),
            member_id: Some("member".into()),
            retention_time: None,
            topics: vec![
                OffsetCommitTopic {
                    topic_name: "topic".into(),
                    partitions: vec![
                        OffsetCommitPartition {
                            partition_id: 5,
                            offset: 6,
                            timestamp: 7,
                            metadata: Some("metadata".into()),
                        },
                    ],
                },
            ],
        };

        let data = vec![
            /* OffsetCommitRequest
             * RequestHeader */ 0, 8 /* api_key */, 0,
            1 /* api_version */, 0, 0, 0, 123 /* correlation_id */, 0, 6, b'c', b'l', b'i', b'e', b'n',
            b't' /* client_id */, 0, 8, b'c', b'o', b'n', b's', b'u', b'm', b'e', b'r' /* group_id */, 0, 0,
            1, 200 /* group_generation_id */, 0, 6, b'm', b'e', b'm', b'b', b'e', b'r' /* member_id */,
            /* topics: [OffsetCommitTopic] */ 0, 0, 0, 1, /* OffsetCommitTopic */ 0, 5, b't', b'o', b'p',
            b'i', b'c' /* topic_name */, /* partitions: [OffsetCommitPartition] */ 0, 0, 0, 1,
            /* OffsetCommitPartition */ 0, 0, 0, 5 /* partition */, 0, 0, 0, 0, 0, 0, 0, 6 /* offset */,
            0, 0, 0, 0, 0, 0, 0, 7 /* timestamp */, 0, 8, b'm', b'e', b't', b'a', b'd', b'a', b't',
            b'a' /* metadata */,
        ];

        let mut buf = BytesMut::with_capacity(128);

        req.encode(&mut buf).unwrap();

        assert_eq!(req.size(req.header.api_version), buf.len());

        assert_eq!(&buf[..], &data[..]);
    }

    #[test]
    fn test_encode_offset_commit_request_v2() {
        let req = OffsetCommitRequest {
            header: RequestHeader {
                api_key: ApiKeys::OffsetCommit as ApiKey,
                api_version: 2,
                correlation_id: 123,
                client_id: Some("client".into()),
            },
            group_id: Some("consumer".into()),
            group_generation_id: Some(456),
            member_id: Some("member".into()),
            retention_time: Some(789),
            topics: vec![
                OffsetCommitTopic {
                    topic_name: "topic".into(),
                    partitions: vec![
                        OffsetCommitPartition {
                            partition_id: 5,
                            offset: 6,
                            timestamp: Default::default(),
                            metadata: Some("metadata".into()),
                        },
                    ],
                },
            ],
        };

        let data = vec![
            /* OffsetCommitRequest
             * RequestHeader */ 0, 8 /* api_key */, 0,
            2 /* api_version */, 0, 0, 0, 123 /* correlation_id */, 0, 6, b'c', b'l', b'i', b'e', b'n',
            b't' /* client_id */, 0, 8, b'c', b'o', b'n', b's', b'u', b'm', b'e', b'r' /* group_id */, 0, 0,
            1, 200 /* group_generation_id */, 0, 6, b'm', b'e', b'm', b'b', b'e', b'r' /* member_id */, 0, 0,
            0, 0, 0, 0, 3, 21 /* retention_time */, /* topics: [OffsetCommitTopic] */ 0, 0, 0, 1,
            /* OffsetCommitTopic */ 0, 5, b't', b'o', b'p', b'i', b'c' /* topic_name */,
            /* partitions: [OffsetCommitPartition] */ 0, 0, 0, 1, /* OffsetCommitPartition */ 0, 0, 0,
            5 /* partition */, 0, 0, 0, 0, 0, 0, 0, 6 /* offset */, 0, 8, b'm', b'e', b't', b'a', b'd', b'a',
            b't', b'a' /* metadata */,
        ];

        let mut buf = BytesMut::with_capacity(128);

        req.encode(&mut buf).unwrap();

        assert_eq!(req.size(req.header.api_version), buf.len());

        assert_eq!(&buf[..], &data[..]);
    }

    #[test]
    fn test_parse_offset_commit_response() {
        let response = OffsetCommitResponse {
            header: ResponseHeader { correlation_id: 123 },
            topics: vec![
                OffsetCommitTopicStatus {
                    topic_name: "topic".to_owned(),
                    partitions: vec![
                        OffsetCommitPartitionStatus {
                            partition_id: 1,
                            error_code: 2,
                        },
                    ],
                },
            ],
        };

        let data = vec![
            /* ResponseHeader */ 0, 0, 0, 123 /* correlation_id */,
            /* topics: [OffsetCommitTopicStatus] */ 0, 0, 0, 1, 0, 5, b't', b'o', b'p', b'i',
            b'c' /* topic_name */, /* partitions: [OffsetCommitPartitionStatus] */ 0, 0, 0, 1, 0, 0, 0,
            1 /* partition */, 0, 2 /* error_code */,
        ];

        let res = parse_offset_commit_response(&data[..]);

        display_parse_error::<_>(&data[..], res.clone());

        assert_eq!(res, IResult::Done(&[][..], response));
    }
}
